{"ast":null,"code":"import axios, { AxiosHeaders } from 'axios';\n\n// API Response Types\n\nclass ApiClient {\n  constructor() {\n    this.client = void 0;\n    this.client = axios.create({\n      baseURL: `${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/api/v1`,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // Add request interceptor to include JWT token and handle token refresh\n    this.client.interceptors.request.use(async config => {\n      const token = localStorage.getItem('token');\n      const tokenExpiry = localStorage.getItem('token_expiry');\n      if (token && tokenExpiry) {\n        var _config$url;\n        // Check if token is about to expire (within 5 minutes)\n        const expiryTime = parseInt(tokenExpiry);\n        const currentTime = Date.now();\n        const timeToExpiry = expiryTime - currentTime;\n        console.log('Token status in request interceptor:', {\n          currentTime: new Date(currentTime).toISOString(),\n          expiryTime: new Date(expiryTime).toISOString(),\n          timeToExpiry: Math.floor(timeToExpiry / 1000) + ' seconds'\n        });\n        if (currentTime + 5 * 60 * 1000 >= expiryTime && !((_config$url = config.url) !== null && _config$url !== void 0 && _config$url.includes('/auth/refresh'))) {\n          console.log('Token refresh needed in request interceptor');\n          try {\n            var _response$data;\n            const response = await this.refreshToken();\n            if (response.success && (_response$data = response.data) !== null && _response$data !== void 0 && _response$data.access_token) {\n              // Update tokens in localStorage\n              localStorage.setItem('token', response.data.access_token);\n              localStorage.setItem('token_expiry', String(Date.now() + response.data.expires_in * 1000));\n\n              // Verify token storage\n              const newToken = localStorage.getItem('token');\n              const newExpiry = localStorage.getItem('token_expiry');\n              if (!newToken || !newExpiry) {\n                console.error('Failed to store refreshed tokens in request interceptor');\n                localStorage.removeItem('token');\n                localStorage.removeItem('token_expiry');\n                window.location.href = '/login';\n                return Promise.reject(new Error('Failed to store authentication tokens'));\n              }\n              config.headers.Authorization = `Bearer ${newToken}`;\n              return config;\n            }\n          } catch (error) {\n            console.error('Token refresh failed in request interceptor:', error);\n            // Clear tokens and redirect to login if refresh fails\n            localStorage.removeItem('token');\n            localStorage.removeItem('token_expiry');\n            window.location.href = '/login';\n            return Promise.reject(error);\n          }\n        }\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      return config;\n    });\n\n    // Add response interceptor for error handling with enhanced logging and token verification\n    this.client.interceptors.response.use(response => response, async error => {\n      var _error$response, _error$response2, _originalRequest$url;\n      const originalRequest = error.config;\n      console.log('Response error intercepted:', {\n        status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n        url: originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.url,\n        method: originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.method\n      });\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 401 && originalRequest && !((_originalRequest$url = originalRequest.url) !== null && _originalRequest$url !== void 0 && _originalRequest$url.includes('/auth/refresh'))) {\n        console.log('Unauthorized error detected, attempting token refresh');\n        try {\n          var _response$data2;\n          const response = await this.refreshToken();\n          if (response.success && (_response$data2 = response.data) !== null && _response$data2 !== void 0 && _response$data2.access_token) {\n            // Update tokens in localStorage\n            localStorage.setItem('token', response.data.access_token);\n            localStorage.setItem('token_expiry', String(Date.now() + response.data.expires_in * 1000));\n\n            // Verify token storage\n            const newToken = localStorage.getItem('token');\n            const newExpiry = localStorage.getItem('token_expiry');\n            if (!newToken || !newExpiry) {\n              console.error('Failed to store refreshed tokens in response interceptor');\n              localStorage.removeItem('token');\n              localStorage.removeItem('token_expiry');\n              window.location.href = '/login';\n              return Promise.reject(new Error('Failed to store authentication tokens'));\n            }\n            console.log('Token refresh successful, retrying original request');\n            // Retry the original request with new token\n            const newRequest = {\n              ...originalRequest\n            };\n            if (newRequest.headers instanceof Object) {\n              newRequest.headers = new AxiosHeaders({\n                ...originalRequest.headers,\n                Authorization: `Bearer ${newToken}`\n              });\n            }\n            return this.client.request(newRequest);\n          }\n        } catch (refreshError) {\n          console.error('Token refresh failed in response interceptor:', refreshError);\n          // Clear tokens before redirecting\n          localStorage.removeItem('token');\n          localStorage.removeItem('token_expiry');\n        }\n        console.log('Authentication failed, redirecting to login');\n        // If refresh failed, redirect to login\n        window.location.href = '/login';\n      }\n      return Promise.reject(error);\n    });\n  }\n\n  // Auth Management\n  async signup(data) {\n    try {\n      const formData = new FormData();\n      formData.append('email', data.email);\n      formData.append('username', data.username);\n      formData.append('password', data.password);\n      const response = await this.client.post('/auth/signup', formData, {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      if (response.data.access_token) {\n        localStorage.setItem('token', response.data.access_token);\n        localStorage.setItem('token_expiry', String(Date.now() + response.data.expires_in * 1000));\n      }\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      const errorMessage = this.handleError(error);\n      console.error('API Error:', errorMessage);\n      return {\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n  async login(data) {\n    try {\n      console.log('Attempting login with:', {\n        username: data.username\n      });\n      const formData = new URLSearchParams();\n      formData.append('username', data.username);\n      formData.append('password', data.password);\n      formData.append('grant_type', 'password');\n      const response = await this.client.post('/auth/login', formData.toString(), {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        withCredentials: true // Required for cookies\n      });\n      if (response.data.access_token) {\n        localStorage.setItem('token', response.data.access_token);\n        localStorage.setItem('token_expiry', String(Date.now() + response.data.expires_in * 1000));\n      }\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async refreshToken() {\n    try {\n      const response = await this.client.post('/auth/refresh', {}, {\n        withCredentials: true\n      });\n      if (response.data.access_token) {\n        localStorage.setItem('token', response.data.access_token);\n        localStorage.setItem('token_expiry', String(Date.now() + response.data.expires_in * 1000));\n      }\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async logout() {\n    try {\n      await this.client.post('/auth/logout', {}, {\n        withCredentials: true\n      });\n      localStorage.removeItem('token');\n      localStorage.removeItem('token_expiry');\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n\n  // Agent Management\n  async getAgentStatus(agentType) {\n    try {\n      const response = await this.client.get(`/agents/${agentType}/status`);\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async startAgent(agentType) {\n    try {\n      await this.client.post(`/agents/${agentType}/start`);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async stopAgent(agentType) {\n    try {\n      await this.client.post(`/agents/${agentType}/stop`);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n\n  // Strategy Management\n  async createStrategy(strategy) {\n    try {\n      const response = await this.client.post('/strategies/trading/create', strategy);\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async getStrategies() {\n    try {\n      const response = await this.client.get('/strategies');\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n\n  // Wallet Management\n  async createWallet(name) {\n    try {\n      const response = await this.client.post('/wallet/create', {\n        name\n      });\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async confirmWallet(walletAddress) {\n    try {\n      await this.client.post('/wallet/confirm', {\n        walletAddress,\n        confirmed: true\n      });\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async getWalletBalance(walletAddress) {\n    try {\n      const response = await this.client.get(`/wallet/balance/${walletAddress}`);\n      return {\n        data: response.data.balance,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  async getWalletTransactions(walletAddress) {\n    try {\n      const response = await this.client.get(`/wallet/transactions/${walletAddress}`);\n      return {\n        data: response.data,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: this.handleError(error),\n        success: false\n      };\n    }\n  }\n  handleError(error) {\n    var _error$response3, _error$response3$data;\n    // Handle API error responses\n    if ((_error$response3 = error.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && _error$response3$data.detail) {\n      return error.response.data.detail;\n    }\n    // Handle network errors\n    if (error.message === 'Network Error') {\n      return 'Unable to connect to server. Please check your internet connection.';\n    }\n    // Handle timeout errors\n    if (error.code === 'ECONNABORTED') {\n      return 'Request timed out. Please try again.';\n    }\n    // Handle other axios errors\n    if (error.message) {\n      return error.message;\n    }\n    return 'An unexpected error occurred. Please try again.';\n  }\n}\nexport const apiClient = new ApiClient();\nexport default apiClient;","map":{"version":3,"names":["axios","AxiosHeaders","ApiClient","constructor","client","create","baseURL","process","env","REACT_APP_API_URL","headers","interceptors","request","use","config","token","localStorage","getItem","tokenExpiry","_config$url","expiryTime","parseInt","currentTime","Date","now","timeToExpiry","console","log","toISOString","Math","floor","url","includes","_response$data","response","refreshToken","success","data","access_token","setItem","String","expires_in","newToken","newExpiry","error","removeItem","window","location","href","Promise","reject","Error","Authorization","_error$response","_error$response2","_originalRequest$url","originalRequest","status","method","_response$data2","newRequest","Object","refreshError","signup","formData","FormData","append","email","username","password","post","errorMessage","handleError","login","URLSearchParams","toString","withCredentials","logout","getAgentStatus","agentType","get","startAgent","stopAgent","createStrategy","strategy","getStrategies","createWallet","name","confirmWallet","walletAddress","confirmed","getWalletBalance","balance","getWalletTransactions","_error$response3","_error$response3$data","detail","message","code","apiClient"],"sources":["/home/ubuntu/repos/tradingbot/src/frontend/src/api/client.ts"],"sourcesContent":["import axios, { AxiosInstance, AxiosError, AxiosHeaders } from 'axios';\n\n// API Response Types\nexport interface ApiResponse<T> {\n  data?: T;\n  error?: string;\n  success: boolean;\n}\n\nexport interface AuthResponse {\n  access_token: string;\n  token_type: string;\n  expires_in: number;\n}\n\nexport interface SignupData {\n  email: string;\n  username: string;\n  password: string;\n}\n\nexport interface LoginData {\n  username: string;\n  password: string;\n}\n\nexport interface AgentResponse {\n  id: string;\n  type: 'trading' | 'defi';\n  status: 'running' | 'stopped' | 'error';\n  lastUpdated: string;\n}\n\nexport interface StrategyResponse {\n  id: string;\n  name: string;\n  type: string;\n  parameters: Record<string, any>;\n  status: 'active' | 'inactive';\n  createdAt: string;\n}\n\nexport interface WalletResponse {\n  address: string;\n  publicKey: string;\n  balance: string;\n  transactions: Array<{\n    hash: string;\n    type: string;\n    amount: string;\n    status: string;\n    timestamp: string;\n  }>;\n}\n\nclass ApiClient {\n  private client: AxiosInstance;\n\n  constructor() {\n    this.client = axios.create({\n      baseURL: `${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/api/v1`,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    // Add request interceptor to include JWT token and handle token refresh\n    this.client.interceptors.request.use(async (config) => {\n      const token = localStorage.getItem('token');\n      const tokenExpiry = localStorage.getItem('token_expiry');\n      \n      if (token && tokenExpiry) {\n        // Check if token is about to expire (within 5 minutes)\n        const expiryTime = parseInt(tokenExpiry);\n        const currentTime = Date.now();\n        const timeToExpiry = expiryTime - currentTime;\n        \n        console.log('Token status in request interceptor:', {\n          currentTime: new Date(currentTime).toISOString(),\n          expiryTime: new Date(expiryTime).toISOString(),\n          timeToExpiry: Math.floor(timeToExpiry / 1000) + ' seconds'\n        });\n        \n        if (currentTime + 5 * 60 * 1000 >= expiryTime && !config.url?.includes('/auth/refresh')) {\n          console.log('Token refresh needed in request interceptor');\n          try {\n            const response = await this.refreshToken();\n            if (response.success && response.data?.access_token) {\n              // Update tokens in localStorage\n              localStorage.setItem('token', response.data.access_token);\n              localStorage.setItem('token_expiry', String(Date.now() + (response.data.expires_in * 1000)));\n              \n              // Verify token storage\n              const newToken = localStorage.getItem('token');\n              const newExpiry = localStorage.getItem('token_expiry');\n              \n              if (!newToken || !newExpiry) {\n                console.error('Failed to store refreshed tokens in request interceptor');\n                localStorage.removeItem('token');\n                localStorage.removeItem('token_expiry');\n                window.location.href = '/login';\n                return Promise.reject(new Error('Failed to store authentication tokens'));\n              }\n              \n              config.headers.Authorization = `Bearer ${newToken}`;\n              return config;\n            }\n          } catch (error) {\n            console.error('Token refresh failed in request interceptor:', error);\n            // Clear tokens and redirect to login if refresh fails\n            localStorage.removeItem('token');\n            localStorage.removeItem('token_expiry');\n            window.location.href = '/login';\n            return Promise.reject(error);\n          }\n        }\n        \n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      return config;\n    });\n\n    // Add response interceptor for error handling with enhanced logging and token verification\n    this.client.interceptors.response.use(\n      (response) => response,\n      async (error: AxiosError) => {\n        const originalRequest = error.config;\n        console.log('Response error intercepted:', {\n          status: error.response?.status,\n          url: originalRequest?.url,\n          method: originalRequest?.method\n        });\n        \n        if (error.response?.status === 401 && originalRequest && !originalRequest.url?.includes('/auth/refresh')) {\n          console.log('Unauthorized error detected, attempting token refresh');\n          try {\n            const response = await this.refreshToken();\n            if (response.success && response.data?.access_token) {\n              // Update tokens in localStorage\n              localStorage.setItem('token', response.data.access_token);\n              localStorage.setItem('token_expiry', String(Date.now() + (response.data.expires_in * 1000)));\n              \n              // Verify token storage\n              const newToken = localStorage.getItem('token');\n              const newExpiry = localStorage.getItem('token_expiry');\n              \n              if (!newToken || !newExpiry) {\n                console.error('Failed to store refreshed tokens in response interceptor');\n                localStorage.removeItem('token');\n                localStorage.removeItem('token_expiry');\n                window.location.href = '/login';\n                return Promise.reject(new Error('Failed to store authentication tokens'));\n              }\n              \n              console.log('Token refresh successful, retrying original request');\n              // Retry the original request with new token\n              const newRequest = { ...originalRequest };\n              if (newRequest.headers instanceof Object) {\n                newRequest.headers = new AxiosHeaders({\n                  ...originalRequest.headers,\n                  Authorization: `Bearer ${newToken}`\n                });\n              }\n              return this.client.request(newRequest);\n            }\n          } catch (refreshError) {\n            console.error('Token refresh failed in response interceptor:', refreshError);\n            // Clear tokens before redirecting\n            localStorage.removeItem('token');\n            localStorage.removeItem('token_expiry');\n          }\n          \n          console.log('Authentication failed, redirecting to login');\n          // If refresh failed, redirect to login\n          window.location.href = '/login';\n        }\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // Auth Management\n  async signup(data: SignupData): Promise<ApiResponse<AuthResponse>> {\n    try {\n      const formData = new FormData();\n      formData.append('email', data.email);\n      formData.append('username', data.username);\n      formData.append('password', data.password);\n      \n      const response = await this.client.post('/auth/signup', formData, {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      });\n      \n      if (response.data.access_token) {\n        localStorage.setItem('token', response.data.access_token);\n        localStorage.setItem('token_expiry', String(Date.now() + (response.data.expires_in * 1000)));\n      }\n      return { data: response.data, success: true };\n    } catch (error) {\n      const errorMessage = this.handleError(error);\n      console.error('API Error:', errorMessage);\n      return { error: errorMessage, success: false };\n    }\n  }\n\n  async login(data: LoginData): Promise<ApiResponse<AuthResponse>> {\n    try {\n      console.log('Attempting login with:', { username: data.username });\n      const formData = new URLSearchParams();\n      formData.append('username', data.username);\n      formData.append('password', data.password);\n      formData.append('grant_type', 'password');\n      \n      const response = await this.client.post('/auth/login', formData.toString(), {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        withCredentials: true, // Required for cookies\n      });\n      \n      if (response.data.access_token) {\n        localStorage.setItem('token', response.data.access_token);\n        localStorage.setItem('token_expiry', String(Date.now() + (response.data.expires_in * 1000)));\n      }\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async refreshToken(): Promise<ApiResponse<AuthResponse>> {\n    try {\n      const response = await this.client.post('/auth/refresh', {}, {\n        withCredentials: true,\n      });\n      \n      if (response.data.access_token) {\n        localStorage.setItem('token', response.data.access_token);\n        localStorage.setItem('token_expiry', String(Date.now() + (response.data.expires_in * 1000)));\n      }\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async logout(): Promise<ApiResponse<void>> {\n    try {\n      await this.client.post('/auth/logout', {}, {\n        withCredentials: true,\n      });\n      localStorage.removeItem('token');\n      localStorage.removeItem('token_expiry');\n      return { success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  // Agent Management\n  async getAgentStatus(agentType: string): Promise<ApiResponse<AgentResponse>> {\n    try {\n      const response = await this.client.get(`/agents/${agentType}/status`);\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async startAgent(agentType: string): Promise<ApiResponse<void>> {\n    try {\n      await this.client.post(`/agents/${agentType}/start`);\n      return { success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async stopAgent(agentType: string): Promise<ApiResponse<void>> {\n    try {\n      await this.client.post(`/agents/${agentType}/stop`);\n      return { success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  // Strategy Management\n  async createStrategy(strategy: {\n    name: string;\n    promotion_words: string;\n    timeframe: string;\n    risk_level: string;\n    description: string;\n  }): Promise<ApiResponse<StrategyResponse>> {\n    try {\n      const response = await this.client.post('/strategies/trading/create', strategy);\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async getStrategies(): Promise<ApiResponse<StrategyResponse[]>> {\n    try {\n      const response = await this.client.get('/strategies');\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  // Wallet Management\n  async createWallet(name: string): Promise<ApiResponse<WalletResponse>> {\n    try {\n      const response = await this.client.post('/wallet/create', { name });\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async confirmWallet(walletAddress: string): Promise<ApiResponse<void>> {\n    try {\n      await this.client.post('/wallet/confirm', { walletAddress, confirmed: true });\n      return { success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async getWalletBalance(walletAddress: string): Promise<ApiResponse<string>> {\n    try {\n      const response = await this.client.get(`/wallet/balance/${walletAddress}`);\n      return { data: response.data.balance, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  async getWalletTransactions(walletAddress: string): Promise<ApiResponse<WalletResponse['transactions']>> {\n    try {\n      const response = await this.client.get(`/wallet/transactions/${walletAddress}`);\n      return { data: response.data, success: true };\n    } catch (error) {\n      return { error: this.handleError(error), success: false };\n    }\n  }\n\n  private handleError(error: any): string {\n    // Handle API error responses\n    if (error.response?.data?.detail) {\n      return error.response.data.detail;\n    }\n    // Handle network errors\n    if (error.message === 'Network Error') {\n      return 'Unable to connect to server. Please check your internet connection.';\n    }\n    // Handle timeout errors\n    if (error.code === 'ECONNABORTED') {\n      return 'Request timed out. Please try again.';\n    }\n    // Handle other axios errors\n    if (error.message) {\n      return error.message;\n    }\n    return 'An unexpected error occurred. Please try again.';\n  }\n}\n\nexport const apiClient = new ApiClient();\nexport default apiClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}